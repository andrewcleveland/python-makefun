{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"makefun \u00b6 Dynamically create python functions with a proper signature. makefun help you create functions dynamically, with the signature of your choice. It was largely inspired by decorator , and created mainly to cover one of its limitations . Thanks micheles for this great piece of work! The typical use cases are: creating signature-preserving function wrappers - just like functools.wraps but with accurate TypeError exception raising when user-provided arguments are wrong, and with a very convenient way to access argument values. creating function wrappers that have more or less arguments that the function they wrap. A bit like functools.partial but a lot more flexible and friendly for your users. For example, I use it in my pytest plugins to add a requests parameter to users' tests or fixtures when they do not already have it. more generally, creating functions with a signature derived from a reference signature , or even creating functions with a signature completely defined at runtime . It currently supports three ways to define the signature of the created function from a given reference function, e.g. foo . from strings, e.g. 'foo(a, b=1)' from Signature objects, either manually created, or obtained by using the inspect.signature (or its backport funcsigs.signature ) method. creating signature-preserving decorators Creating decorators and creating signature-preserving function wrappers are two independent problems. makefun is solely focused on the second problem. If you wish to solve the first problem you can look at decopatch . It provides a compact syntax, relying on makefun , if you wish to tackle both at once. Installing \u00b6 > pip install makefun Usage \u00b6 1- Ex-nihilo creation \u00b6 Let's create a function foo(b, a=0) implemented by func_impl . The easiest way to provide the signature is as a str : from makefun import create_function # (1) define the signature. Warning: do not put 'def' keyword here! func_sig = \"foo(b, a=0)\" # (2) define the function implementation def func_impl ( * args , ** kwargs ): \"\"\"This docstring will be used in the generated function by default\"\"\" print ( \"func_impl called !\" ) return args , kwargs # (3) create the dynamic function gen_func = create_function ( func_sig , func_impl ) We can test it: >>> args , kwargs = gen_func ( 2 ) func_impl called ! >>> assert args == () >>> assert kwargs == { 'a' : 0 , 'b' : 2 } You can also: remove the name from the signature string (e.g. '(b, a=0)' ) to directly use the function name of func_impl . override the function name, docstring, qualname and module name if you pass a non-None func_name , doc , qualname and module_name argument add other attributes on the generated function if you pass additional keyword arguments See help(create_function) for details. Arguments mapping \u00b6 We can see above that args is empty, even if we called gen_func with a positional argument. This is completely normal: this is because the created function does not expose (*args, **kwargs) but exposes the desired signature (b, a=0) . So as for usual python function calls, we lose the information about what was provided as positional and what was provided as keyword. You can try it yourself: write a function def foo(b, a=0) and now try to guess from the function body what was provided as positional, and what was provided as keyword... This behaviour is actually a great feature because it makes it much easier to develop the func_impl ! Indeed, except if your desired signature contains positional-only (not yet available as of python 3.7) or var-positional (e.g. *args ) arguments, you will always find all named arguments in **kwargs . More compact syntax \u00b6 You can use the @with_signature decorator to perform exactly the same things than create_function , but in a more compact way: from makefun import with_signature @with_signature ( \"foo(b, a=0)\" ) def gen_func ( * args , ** kwargs ): \"\"\"This docstring will be used in the generated function by default\"\"\" print ( \"func_impl called !\" ) return args , kwargs It also has the capability to take None as a signature, if you just want to update the metadata ( func_name , doc , qualname , module_name ) without creating any function: @with_signature ( None , func_name = 'f' ) def foo ( a ): return a assert foo . __name__ == 'f' See help(with_signature) for details. PEP484 type hints in str \u00b6 PEP484 type hints are supported in string function definitions: func_sig = \"foo(b: int, a: float = 0) -> str\" PEP484 type comments are also supported: func_signature = \"\"\" foo(b, # type: int a = 0, # type: float ): # type: (...) -> str \"\"\" but unfortunately inspect.signature is not able to detect them so the generated function does not contain the annotations. See this example . Using Signature objects \u00b6 create_function and @with_signature are able to accept a Signature object as input, instead of a str . That might be more convenient than using strings to programmatically define signatures. For example we can rewrite the above script using Signature : from makefun import with_signature from inspect import Signature , Parameter # (1) define the signature using objects. parameters = [ Parameter ( 'b' , kind = Parameter . POSITIONAL_OR_KEYWORD ), Parameter ( 'a' , kind = Parameter . POSITIONAL_OR_KEYWORD , default = 0 ), ] func_sig = Signature ( parameters ) func_name = 'foo' # (2) define the function @with_signature ( func_sig , func_name = func_name ) def gen_func ( * args , ** kwargs ): \"\"\"This docstring will be used in the generated function by default\"\"\" print ( \"func_impl called !\" ) return args , kwargs Note that Signature objects do not contain any function name information. You therefore have to provide an explicit func_name argument to @with_signature (or to create_function ) as shown above. Signature availability in python 2 In python 2 the inspect package does not provide any signature-related features, but a complete backport is available: funcsigs . 2- Deriving from existing signatures \u00b6 In many real-world applications we want to reuse \"as is\", or slightly modify, an existing signature. Copying a signature \u00b6 If you just want to expose the same signature as a reference function (and not wrap it nor appear like it), the easiest way to copy the signature from another function f is to use signature(f) from inspect / funcsigs . Signature-preserving function wrappers \u00b6 @functools.wraps is a famous decorator to create \"signature-preserving\" function wrappers. However it does not actually preserve the signature, it just uses a trick (setting the __wrapped__ attribute) to trigger special dedicated behaviour in stdlib 's help() and signature() methods. See here . This has two major limitations: the wrapper code will execute even when the provided arguments are invalid . the wrapper code can not easily access an argument using its name, from the received *args, **kwargs . Indeed one would have to handle all cases (positional, keyword, default) and therefore to use something like Signature.bind() . makefun provides a convenient replacement for @wraps that fixes these two issues: from makefun import wraps # a dummy function def foo ( a , b = 1 ): \"\"\" foo doc \"\"\" return a + b # our signature-preserving wrapper @wraps ( foo ) def enhanced_foo ( * args , ** kwargs ): print ( 'hello!' ) print ( 'b= %s ' % kwargs [ 'b' ]) # we can reliably access 'b' return foo ( * args , ** kwargs ) We can check that the wrapper behaves correctly whatever the call modes: >>> assert enhanced_foo ( 1 , 2 ) == 3 # positional 'b' hello ! b = 2 >>> assert enhanced_foo ( b = 0 , a = 1 ) == 1 # keyword 'b' hello ! b = 0 >>> assert enhanced_foo ( 1 ) == 2 # default 'b' hello ! b = 1 And let's pass wrong arguments to it: we see that the wrapper is not executed. >>> enhanced_foo () TypeError : foo () missing 1 required positional argument : 'a' You can try to do the same experiment with functools.wraps to see the difference. Finally note that a create_wrapper function is also provided for convenience ; it is the equivalent of @wraps but as a standard function - not a decorator. creating signature-preserving decorators Creating decorators and creating signature-preserving function wrappers are two independent problems. makefun is solely focused on the second problem. If you wish to solve the first problem you can look at decopatch . It provides a compact syntax, relying on makefun , if you wish to tackle both at once. Editing a signature \u00b6 Below we show how to add a parameter to a function. We first capture its Signature using inspect.signature(f) , we modify it to add a parameter, and finally we use it in wraps to create our final function: from makefun import wraps from inspect import signature , Parameter # (0) the reference function def foo ( b , a = 0 ): print ( \"foo called: b= %s , a= %s \" % ( b , a )) return b , a # (1a) capture the signature of reference function `foo` foo_sig = signature ( foo ) print ( \"Original Signature: %s \" % foo_sig ) # (1b) modify the signature to add a new parameter 'z' as first argument params = list ( foo_sig . parameters . values ()) params . insert ( 0 , Parameter ( 'z' , kind = Parameter . POSITIONAL_OR_KEYWORD )) new_sig = foo_sig . replace ( parameters = params ) print ( \"New Signature: %s \" % new_sig ) # (2) define the wrapper implementation @wraps ( foo , new_sig = new_sig ) def foo_wrapper ( z , * args , ** kwargs ): print ( \"foo_wrapper called ! z= %s \" % z ) # call the foo function output = foo ( * args , ** kwargs ) # return augmented output return z , output # call it assert foo_wrapper ( 3 , 2 ) == 3 , ( 2 , 0 ) yields Original Signature: (b, a=0) New Signature: (z, b, a=0) foo_wrapper called ! z=3 foo called: b=2, a=0 This way you can therefore easily create function wrappers with different signatures: not only adding, but also removing parameters, changing their kind (forcing keyword-only for example), etc. The possibilities are as endless as the capabilities of the Signature objects. Two helper functions are provided in this toolbox to make it a bit easier for you to edit Signature objects: remove_signature_parameters creates a new signature from an existing one by removing all parameters corresponding to the names provided add_signature_parameters prepends the Parameter s provided in its first= argument, and appends the ones provided in its last argument. from makefun import add_signature_parameters , remove_signature_parameters def foo ( b , c , a = 0 ): pass # original signature foo_sig = signature ( foo ) print ( \"original signature: %s \" % foo_sig ) # let's modify it new_sig = add_signature_parameters ( foo_sig , first = Parameter ( 'z' , kind = Parameter . POSITIONAL_OR_KEYWORD ), last = Parameter ( 'o' , kind = Parameter . POSITIONAL_OR_KEYWORD , default = True ) ) new_sig = remove_signature_parameters ( new_sig , 'b' , 'a' ) print ( \"modified signature: %s \" % new_sig ) yields original signature: ( b, c, a = 0 ) modified signature: ( z, c, o = True ) They might save you a few lines of code if your use-case is not too specific. Removing parameters easily \u00b6 As goodies, makefun provides a partial function that are equivalent to functools.partial , except that it is fully signature-preserving and modifies the documentation with a nice helper message explaining that this is a partial view: def foo ( x , y ): \"\"\" a `foo` function :param x: :param y: :return: \"\"\" return x + y from makefun import partial bar = partial ( foo , x = 12 ) we can test it: >>> assert bar ( 1 ) == 13 >>> help ( bar ) Help on function bar in module makefun . tests . test_partial_and_macros : bar ( y ) < This function is equivalent to 'foo(y, x=12)' , see original 'foo' doc below .> a ` foo ` function : param x : : param y : : return : A decorator is also available to create partial views easily for quick tests: @with_partial ( x = 12 ) def foo ( x , y ): \"\"\" a `foo` function :param x: :param y: :return: \"\"\" return x + y 3- Advanced topics \u00b6 Generators and Coroutines \u00b6 create_function and @with_signature will automatically create a generator if your implementation is a generator: # define the implementation def my_generator_impl ( b , a = 0 ): for i in range ( a , b ): yield i * i # create the dynamic function gen_func = create_function ( \"foo(a, b)\" , my_generator_impl ) # verify that the new function is a generator and behaves as such assert isgeneratorfunction ( gen_func ) assert list ( gen_func ( 1 , 4 )) == [ 1 , 4 , 9 ] The same goes for generator-based coroutines: # define the impl that should be called def my_gencoroutine_impl ( first_msg ): second_msg = ( yield first_msg ) yield second_msg # create the dynamic function gen_func = create_function ( \"foo(first_msg='hello')\" , my_gencoroutine_impl ) # verify that the new func is a generator-based coroutine and behaves correctly cor = gen_func ( 'hi' ) assert next ( cor ) == 'hi' assert cor . send ( 'chaps' ) == 'chaps' cor . send ( 'ola' ) # raises StopIteration and asyncio coroutines as well # define the impl that should be called async def my_native_coroutine_impl ( sleep_time ): await sleep ( sleep_time ) return sleep_time # create the dynamic function gen_func = create_function ( \"foo(sleep_time=2)\" , my_native_coroutine_impl ) # verify that the new function is a native coroutine and behaves correctly from asyncio import get_event_loop out = get_event_loop () . run_until_complete ( gen_func ( 5 )) assert out == 5 Generated source code \u00b6 The generated source code is in the __source__ field of the generated function: print ( gen_func . __source__ ) prints the following source code: def foo ( b , a = 0 ): return _func_impl_ ( b = b , a = a ) The _func_impl_ symbol represents your implementation. As already mentioned , you see that the variables are passed to it as keyword arguments when possible ( _func_impl_(b=b) , not simply _func_impl_(b) ). Of course if it is not possible it adapts: gen_func = create_function ( \"foo(a=0, *args, **kwargs)\" , func_impl ) print ( gen_func . __source__ ) prints the following source code: def foo ( a = 0 , * args , ** kwargs ): return _func_impl_ ( a = a , * args , ** kwargs ) Function reference injection \u00b6 In some scenarios you may wish to share the same implementation among several created functions, for example to expose slightly different signatures on top of the same core. In that case you may wish your implementation to know from which dynamically generated function it is being called. For this, simply use inject_as_first_arg=True , and the called function will be injected as the first argument: def core_impl ( f , * args , ** kwargs ): print ( \"This is generic core called by %s \" % f . __name__ ) # here you could use f.__name__ in a if statement to determine what to do if f . __name__ == \"func1\" : print ( \"called from func1 !\" ) return args , kwargs # generate 2 functions func1 = create_function ( \"func1(a, b)\" , core_impl , inject_as_first_arg = True ) func2 = create_function ( \"func2(a, d)\" , core_impl , inject_as_first_arg = True ) func1 ( 1 , 2 ) func2 ( 1 , 2 ) yields This is generic core called by func1 called from func1 ! This is generic core called by func2 4. Other goodies \u00b6 @compile_fun \u00b6 A draft decorator to compile any existing function so that users cant debug through it. It can be handy to mask some code from your users for convenience (note that this does not provide any obfuscation, people can still reverse engineer your code easily. Actually the source code even gets copied in the function's __source__ attribute for convenience): from makefun import compile_fun @compile_fun def foo ( a , b ): return a + b assert foo ( 5 , - 5.0 ) == 0 print ( foo . __source__ ) yields @compile_fun def foo(a, b): return a + b If the function closure includes functions, they are recursively replaced with compiled versions too (only for this closure, this does not modify them otherwise). You may disable this behaviour entirely with recurse=False , or exclude some symbols from this recursion with the except_names=(...) arg (a tuple of names to exclude). IMPORTANT this decorator is a \"goodie\" in early stage and has not been extensively tested. Feel free to contribute ! Note that according to this post compiling does not make the code run any faster. Known issues: NameError may appear if your function code depends on symbols that have not yet been defined. Make sure all symbols exist first ! See this issue . Main features / benefits \u00b6 Generate functions with a dynamically defined signature : the signature can be provided as a string or as a Signature object, thus making it handy to derive from other functions. Implement them easily : the generated functions redirect their calls to the provided implementation function. As long as the signature is compliant, it will work as expected. For example the signature can be specific ( a: int, b=None ), and the implementation more generic ( *args, **kwargs ). Arguments will always be passed as keywords arguments when possible. Replace `@functools.wraps so that it correctly preserves signatures, and enable you to easily access named arguments. See Also \u00b6 decorator , which largely inspired this code PEP362 - Function Signature Object A blog entry on dynamic function creation functools.wraps Others \u00b6 Do you like this library ? You might also like my other python libraries Want to contribute ? \u00b6 Details on the github page: https://github.com/smarie/python-makefun","title":"Home"},{"location":"#makefun","text":"Dynamically create python functions with a proper signature. makefun help you create functions dynamically, with the signature of your choice. It was largely inspired by decorator , and created mainly to cover one of its limitations . Thanks micheles for this great piece of work! The typical use cases are: creating signature-preserving function wrappers - just like functools.wraps but with accurate TypeError exception raising when user-provided arguments are wrong, and with a very convenient way to access argument values. creating function wrappers that have more or less arguments that the function they wrap. A bit like functools.partial but a lot more flexible and friendly for your users. For example, I use it in my pytest plugins to add a requests parameter to users' tests or fixtures when they do not already have it. more generally, creating functions with a signature derived from a reference signature , or even creating functions with a signature completely defined at runtime . It currently supports three ways to define the signature of the created function from a given reference function, e.g. foo . from strings, e.g. 'foo(a, b=1)' from Signature objects, either manually created, or obtained by using the inspect.signature (or its backport funcsigs.signature ) method. creating signature-preserving decorators Creating decorators and creating signature-preserving function wrappers are two independent problems. makefun is solely focused on the second problem. If you wish to solve the first problem you can look at decopatch . It provides a compact syntax, relying on makefun , if you wish to tackle both at once.","title":"makefun"},{"location":"#installing","text":"> pip install makefun","title":"Installing"},{"location":"#usage","text":"","title":"Usage"},{"location":"#1-ex-nihilo-creation","text":"Let's create a function foo(b, a=0) implemented by func_impl . The easiest way to provide the signature is as a str : from makefun import create_function # (1) define the signature. Warning: do not put 'def' keyword here! func_sig = \"foo(b, a=0)\" # (2) define the function implementation def func_impl ( * args , ** kwargs ): \"\"\"This docstring will be used in the generated function by default\"\"\" print ( \"func_impl called !\" ) return args , kwargs # (3) create the dynamic function gen_func = create_function ( func_sig , func_impl ) We can test it: >>> args , kwargs = gen_func ( 2 ) func_impl called ! >>> assert args == () >>> assert kwargs == { 'a' : 0 , 'b' : 2 } You can also: remove the name from the signature string (e.g. '(b, a=0)' ) to directly use the function name of func_impl . override the function name, docstring, qualname and module name if you pass a non-None func_name , doc , qualname and module_name argument add other attributes on the generated function if you pass additional keyword arguments See help(create_function) for details.","title":"1- Ex-nihilo creation"},{"location":"#arguments-mapping","text":"We can see above that args is empty, even if we called gen_func with a positional argument. This is completely normal: this is because the created function does not expose (*args, **kwargs) but exposes the desired signature (b, a=0) . So as for usual python function calls, we lose the information about what was provided as positional and what was provided as keyword. You can try it yourself: write a function def foo(b, a=0) and now try to guess from the function body what was provided as positional, and what was provided as keyword... This behaviour is actually a great feature because it makes it much easier to develop the func_impl ! Indeed, except if your desired signature contains positional-only (not yet available as of python 3.7) or var-positional (e.g. *args ) arguments, you will always find all named arguments in **kwargs .","title":"Arguments mapping"},{"location":"#more-compact-syntax","text":"You can use the @with_signature decorator to perform exactly the same things than create_function , but in a more compact way: from makefun import with_signature @with_signature ( \"foo(b, a=0)\" ) def gen_func ( * args , ** kwargs ): \"\"\"This docstring will be used in the generated function by default\"\"\" print ( \"func_impl called !\" ) return args , kwargs It also has the capability to take None as a signature, if you just want to update the metadata ( func_name , doc , qualname , module_name ) without creating any function: @with_signature ( None , func_name = 'f' ) def foo ( a ): return a assert foo . __name__ == 'f' See help(with_signature) for details.","title":"More compact syntax"},{"location":"#pep484-type-hints-in-str","text":"PEP484 type hints are supported in string function definitions: func_sig = \"foo(b: int, a: float = 0) -> str\" PEP484 type comments are also supported: func_signature = \"\"\" foo(b, # type: int a = 0, # type: float ): # type: (...) -> str \"\"\" but unfortunately inspect.signature is not able to detect them so the generated function does not contain the annotations. See this example .","title":"PEP484 type hints in str"},{"location":"#using-signature-objects","text":"create_function and @with_signature are able to accept a Signature object as input, instead of a str . That might be more convenient than using strings to programmatically define signatures. For example we can rewrite the above script using Signature : from makefun import with_signature from inspect import Signature , Parameter # (1) define the signature using objects. parameters = [ Parameter ( 'b' , kind = Parameter . POSITIONAL_OR_KEYWORD ), Parameter ( 'a' , kind = Parameter . POSITIONAL_OR_KEYWORD , default = 0 ), ] func_sig = Signature ( parameters ) func_name = 'foo' # (2) define the function @with_signature ( func_sig , func_name = func_name ) def gen_func ( * args , ** kwargs ): \"\"\"This docstring will be used in the generated function by default\"\"\" print ( \"func_impl called !\" ) return args , kwargs Note that Signature objects do not contain any function name information. You therefore have to provide an explicit func_name argument to @with_signature (or to create_function ) as shown above. Signature availability in python 2 In python 2 the inspect package does not provide any signature-related features, but a complete backport is available: funcsigs .","title":"Using Signature objects"},{"location":"#2-deriving-from-existing-signatures","text":"In many real-world applications we want to reuse \"as is\", or slightly modify, an existing signature.","title":"2- Deriving from existing signatures"},{"location":"#copying-a-signature","text":"If you just want to expose the same signature as a reference function (and not wrap it nor appear like it), the easiest way to copy the signature from another function f is to use signature(f) from inspect / funcsigs .","title":"Copying a signature"},{"location":"#signature-preserving-function-wrappers","text":"@functools.wraps is a famous decorator to create \"signature-preserving\" function wrappers. However it does not actually preserve the signature, it just uses a trick (setting the __wrapped__ attribute) to trigger special dedicated behaviour in stdlib 's help() and signature() methods. See here . This has two major limitations: the wrapper code will execute even when the provided arguments are invalid . the wrapper code can not easily access an argument using its name, from the received *args, **kwargs . Indeed one would have to handle all cases (positional, keyword, default) and therefore to use something like Signature.bind() . makefun provides a convenient replacement for @wraps that fixes these two issues: from makefun import wraps # a dummy function def foo ( a , b = 1 ): \"\"\" foo doc \"\"\" return a + b # our signature-preserving wrapper @wraps ( foo ) def enhanced_foo ( * args , ** kwargs ): print ( 'hello!' ) print ( 'b= %s ' % kwargs [ 'b' ]) # we can reliably access 'b' return foo ( * args , ** kwargs ) We can check that the wrapper behaves correctly whatever the call modes: >>> assert enhanced_foo ( 1 , 2 ) == 3 # positional 'b' hello ! b = 2 >>> assert enhanced_foo ( b = 0 , a = 1 ) == 1 # keyword 'b' hello ! b = 0 >>> assert enhanced_foo ( 1 ) == 2 # default 'b' hello ! b = 1 And let's pass wrong arguments to it: we see that the wrapper is not executed. >>> enhanced_foo () TypeError : foo () missing 1 required positional argument : 'a' You can try to do the same experiment with functools.wraps to see the difference. Finally note that a create_wrapper function is also provided for convenience ; it is the equivalent of @wraps but as a standard function - not a decorator. creating signature-preserving decorators Creating decorators and creating signature-preserving function wrappers are two independent problems. makefun is solely focused on the second problem. If you wish to solve the first problem you can look at decopatch . It provides a compact syntax, relying on makefun , if you wish to tackle both at once.","title":"Signature-preserving function wrappers"},{"location":"#editing-a-signature","text":"Below we show how to add a parameter to a function. We first capture its Signature using inspect.signature(f) , we modify it to add a parameter, and finally we use it in wraps to create our final function: from makefun import wraps from inspect import signature , Parameter # (0) the reference function def foo ( b , a = 0 ): print ( \"foo called: b= %s , a= %s \" % ( b , a )) return b , a # (1a) capture the signature of reference function `foo` foo_sig = signature ( foo ) print ( \"Original Signature: %s \" % foo_sig ) # (1b) modify the signature to add a new parameter 'z' as first argument params = list ( foo_sig . parameters . values ()) params . insert ( 0 , Parameter ( 'z' , kind = Parameter . POSITIONAL_OR_KEYWORD )) new_sig = foo_sig . replace ( parameters = params ) print ( \"New Signature: %s \" % new_sig ) # (2) define the wrapper implementation @wraps ( foo , new_sig = new_sig ) def foo_wrapper ( z , * args , ** kwargs ): print ( \"foo_wrapper called ! z= %s \" % z ) # call the foo function output = foo ( * args , ** kwargs ) # return augmented output return z , output # call it assert foo_wrapper ( 3 , 2 ) == 3 , ( 2 , 0 ) yields Original Signature: (b, a=0) New Signature: (z, b, a=0) foo_wrapper called ! z=3 foo called: b=2, a=0 This way you can therefore easily create function wrappers with different signatures: not only adding, but also removing parameters, changing their kind (forcing keyword-only for example), etc. The possibilities are as endless as the capabilities of the Signature objects. Two helper functions are provided in this toolbox to make it a bit easier for you to edit Signature objects: remove_signature_parameters creates a new signature from an existing one by removing all parameters corresponding to the names provided add_signature_parameters prepends the Parameter s provided in its first= argument, and appends the ones provided in its last argument. from makefun import add_signature_parameters , remove_signature_parameters def foo ( b , c , a = 0 ): pass # original signature foo_sig = signature ( foo ) print ( \"original signature: %s \" % foo_sig ) # let's modify it new_sig = add_signature_parameters ( foo_sig , first = Parameter ( 'z' , kind = Parameter . POSITIONAL_OR_KEYWORD ), last = Parameter ( 'o' , kind = Parameter . POSITIONAL_OR_KEYWORD , default = True ) ) new_sig = remove_signature_parameters ( new_sig , 'b' , 'a' ) print ( \"modified signature: %s \" % new_sig ) yields original signature: ( b, c, a = 0 ) modified signature: ( z, c, o = True ) They might save you a few lines of code if your use-case is not too specific.","title":"Editing a signature"},{"location":"#removing-parameters-easily","text":"As goodies, makefun provides a partial function that are equivalent to functools.partial , except that it is fully signature-preserving and modifies the documentation with a nice helper message explaining that this is a partial view: def foo ( x , y ): \"\"\" a `foo` function :param x: :param y: :return: \"\"\" return x + y from makefun import partial bar = partial ( foo , x = 12 ) we can test it: >>> assert bar ( 1 ) == 13 >>> help ( bar ) Help on function bar in module makefun . tests . test_partial_and_macros : bar ( y ) < This function is equivalent to 'foo(y, x=12)' , see original 'foo' doc below .> a ` foo ` function : param x : : param y : : return : A decorator is also available to create partial views easily for quick tests: @with_partial ( x = 12 ) def foo ( x , y ): \"\"\" a `foo` function :param x: :param y: :return: \"\"\" return x + y","title":"Removing parameters easily"},{"location":"#3-advanced-topics","text":"","title":"3- Advanced topics"},{"location":"#generators-and-coroutines","text":"create_function and @with_signature will automatically create a generator if your implementation is a generator: # define the implementation def my_generator_impl ( b , a = 0 ): for i in range ( a , b ): yield i * i # create the dynamic function gen_func = create_function ( \"foo(a, b)\" , my_generator_impl ) # verify that the new function is a generator and behaves as such assert isgeneratorfunction ( gen_func ) assert list ( gen_func ( 1 , 4 )) == [ 1 , 4 , 9 ] The same goes for generator-based coroutines: # define the impl that should be called def my_gencoroutine_impl ( first_msg ): second_msg = ( yield first_msg ) yield second_msg # create the dynamic function gen_func = create_function ( \"foo(first_msg='hello')\" , my_gencoroutine_impl ) # verify that the new func is a generator-based coroutine and behaves correctly cor = gen_func ( 'hi' ) assert next ( cor ) == 'hi' assert cor . send ( 'chaps' ) == 'chaps' cor . send ( 'ola' ) # raises StopIteration and asyncio coroutines as well # define the impl that should be called async def my_native_coroutine_impl ( sleep_time ): await sleep ( sleep_time ) return sleep_time # create the dynamic function gen_func = create_function ( \"foo(sleep_time=2)\" , my_native_coroutine_impl ) # verify that the new function is a native coroutine and behaves correctly from asyncio import get_event_loop out = get_event_loop () . run_until_complete ( gen_func ( 5 )) assert out == 5","title":"Generators and Coroutines"},{"location":"#generated-source-code","text":"The generated source code is in the __source__ field of the generated function: print ( gen_func . __source__ ) prints the following source code: def foo ( b , a = 0 ): return _func_impl_ ( b = b , a = a ) The _func_impl_ symbol represents your implementation. As already mentioned , you see that the variables are passed to it as keyword arguments when possible ( _func_impl_(b=b) , not simply _func_impl_(b) ). Of course if it is not possible it adapts: gen_func = create_function ( \"foo(a=0, *args, **kwargs)\" , func_impl ) print ( gen_func . __source__ ) prints the following source code: def foo ( a = 0 , * args , ** kwargs ): return _func_impl_ ( a = a , * args , ** kwargs )","title":"Generated source code"},{"location":"#function-reference-injection","text":"In some scenarios you may wish to share the same implementation among several created functions, for example to expose slightly different signatures on top of the same core. In that case you may wish your implementation to know from which dynamically generated function it is being called. For this, simply use inject_as_first_arg=True , and the called function will be injected as the first argument: def core_impl ( f , * args , ** kwargs ): print ( \"This is generic core called by %s \" % f . __name__ ) # here you could use f.__name__ in a if statement to determine what to do if f . __name__ == \"func1\" : print ( \"called from func1 !\" ) return args , kwargs # generate 2 functions func1 = create_function ( \"func1(a, b)\" , core_impl , inject_as_first_arg = True ) func2 = create_function ( \"func2(a, d)\" , core_impl , inject_as_first_arg = True ) func1 ( 1 , 2 ) func2 ( 1 , 2 ) yields This is generic core called by func1 called from func1 ! This is generic core called by func2","title":"Function reference injection"},{"location":"#4-other-goodies","text":"","title":"4. Other goodies"},{"location":"#compile_fun","text":"A draft decorator to compile any existing function so that users cant debug through it. It can be handy to mask some code from your users for convenience (note that this does not provide any obfuscation, people can still reverse engineer your code easily. Actually the source code even gets copied in the function's __source__ attribute for convenience): from makefun import compile_fun @compile_fun def foo ( a , b ): return a + b assert foo ( 5 , - 5.0 ) == 0 print ( foo . __source__ ) yields @compile_fun def foo(a, b): return a + b If the function closure includes functions, they are recursively replaced with compiled versions too (only for this closure, this does not modify them otherwise). You may disable this behaviour entirely with recurse=False , or exclude some symbols from this recursion with the except_names=(...) arg (a tuple of names to exclude). IMPORTANT this decorator is a \"goodie\" in early stage and has not been extensively tested. Feel free to contribute ! Note that according to this post compiling does not make the code run any faster. Known issues: NameError may appear if your function code depends on symbols that have not yet been defined. Make sure all symbols exist first ! See this issue .","title":"@compile_fun"},{"location":"#main-features-benefits","text":"Generate functions with a dynamically defined signature : the signature can be provided as a string or as a Signature object, thus making it handy to derive from other functions. Implement them easily : the generated functions redirect their calls to the provided implementation function. As long as the signature is compliant, it will work as expected. For example the signature can be specific ( a: int, b=None ), and the implementation more generic ( *args, **kwargs ). Arguments will always be passed as keywords arguments when possible. Replace `@functools.wraps so that it correctly preserves signatures, and enable you to easily access named arguments.","title":"Main features / benefits"},{"location":"#see-also","text":"decorator , which largely inspired this code PEP362 - Function Signature Object A blog entry on dynamic function creation functools.wraps","title":"See Also"},{"location":"#others","text":"Do you like this library ? You might also like my other python libraries","title":"Others"},{"location":"#want-to-contribute","text":"Details on the github page: https://github.com/smarie/python-makefun","title":"Want to contribute ?"},{"location":"changelog/","text":"Changelog \u00b6 1.9.0 - @compile_fun improvements, bugfix and better exception \u00b6 @compile_fun : added capability to disable recursive compilation ( recurse arg) , and to exclude some names from compilation ( except_names arg). Fixed #49 and #50 Fixed issue ValueError: Cell is empty with @compile_fun . Fixed #48 Now raising an UndefinedSymbolError when a symbol is not known at compilation time. One step towards #47 1.8.0 - new @compile_fun goodie \u00b6 New goodie @compile_fun decorator to compile a function so that it can not be navigated to using the debugger. Fixes #46 1.7.0 - minor goodies update \u00b6 add_signature_parameters now accepts that one specifies a custom index where to insert the new parameters. 1.6.11 - Added version attribute \u00b6 Added __version__ attribute to comply with PEP396, following this guide . Fixes #45 . 1.6.10 - Fixed dependencies 2 \u00b6 Fixed six dependency: also declared as a setup dependency. 1.6.9 - Fixed dependencies \u00b6 Added missing six dependency explicitly. 1.6.8 - Improved performance \u00b6 Improved performance of inner method get_signature_string (used by all entry points) after profiling. 1.6.7 - Increased tolerance to function signatures in python 2 \u00b6 In python 2 some libraries such as attrs can modify the annotations manually, making signature return a string representation that is not compliant with the language version. This raised a SyntaxError in previous versions. The new version silently removes all these annotations in python versions that do not support them. Fixes #39 . 1.6.6 - Bug fix \u00b6 Fixed yet another nasty varpositional-related bug :). Fixes #38 . 1.6.5 - Bug fix \u00b6 Fixed NameError in case of unknown symbols in type hints. Fixes #37 . 1.6.4 - Bug fix and minor improvement \u00b6 Fixed PEP8 error in source code. Fixes #35 . Now string signatures can contain a colon. Fixes #36 1.6.3 - Bug fix with type hints in signature \u00b6 Fixed bug when the return type annotation of the function to create contains non-locally available type hints. Fixes #33 . 1.6.2 - Bug fix with type hints in signature \u00b6 Fixed bug when the signature of the function to create contains non-locally available type hints. Fixes #32 . 1.6.1 - with_partial and partial minor bug fix \u00b6 Fixed partial to support missing and empty docstring. Fixes #31 . 1.6.0 - added with_partial and partial \u00b6 New method partial that behaves like functools.partial , and equivalent decorator @with_partial . Fixes #30 . 1.5.1 - bug fix \u00b6 add_signature_parameters now correctly inserts parameters in the right order when they are prepended (using first= ). Fixed #29 . 1.5.0 - Major refactoring and bugfixes \u00b6 Function creation API: renamed all handler into impl for clarity. Fixes #27 . renamed addsource and addhandler arguments as add_source and add_impl respectively, for consistency signatures can not be provided as a callable anymore - that was far too confusing. If the reference signature is a callable, then use @wraps or create_wrapper , because that's probably what you want to do (= reuse not only the signature but also all metadata). Fixes #26 . the function name is now optional in signatures provided as string. now setting __qualname__ attribute default function name, qualname, doc and module name are the ones from func_impl in create_function and @with_signature , and are the ones from the wrapped function in create_wrapper and @wraps as intuitively expected. Fixes #28 . Wrappers: @wraps and create_wrapper now offer a new_sig argument. In that case the __wrapped__ attribute is not set. Fixes #25 . @wraps and create_wrapper now correctly preserve the __dict__ and other metadata from the wrapped item. Fixes #24 1.4.0 - Non-representable default values are now handled correctly \u00b6 When a non-representable default value was used in the signature to generate, the code failed with a SyntaxError . This case is now correctly handled, by storing the corresponding variable in the generated function's context. Fixes #23 . 1.3.0 - Aliases for signature-preserving wrapper scenarios \u00b6 Now providing a @wraps , equivalent of functools.wraps ; and a create_wrapper equivalent of functools.update_wrapper . Fixes #21 @with_signature now does not override the __name__ when signature is provided as a function. Fixes #22 add_signature_parameters now accepts that parameters are provided as single elements (not necessarily iterables) Updated documentation 1.2.0 - @with_signature supports None \u00b6 None can be used as the desired signature of @with_signature . This indicated that the user does not want to create a new function but only wants to update the metadata. Fixes #20 . 1.1.2 - Fixes \u00b6 Fixed isgeneratorfunction for old python versions, see decorator#63 . Python<3.3-specific function body is now not loaded at all if not needed. 1.1.1 - @with_signature fix \u00b6 inject_as_first_arg was missing from @with_signature , added it. Fixed #18 . 1.1.0 - Support for generators and coroutines \u00b6 Now create_function and @with_signature create the same kind of function than the handler. So if it is a generator, a generator-based coroutine, or an async coroutine, the generated function will adapt. Fixes #6 . 1.0.2 - Fixed @with_signature \u00b6 Now a string signature can be provided to @with_signature without problem. Fixed #17 . 1.0.1 - minor: fixed PyPi doc \u00b6 1.0.0 - New parameters, new goodie, and bugfix \u00b6 @with_signature : now exposes all options of create_function . Fixed #12 . now correctly sets the module name by default. Fixes #13 now accepts None as the new func_signature to declare that the signature is identical to the decorated function. This can be handy to just change the docstring or module name of a function for example. Fixes #15 create_function and @with_signature : New module_name parameter to override the module name. Fixes #14 the handler is now available as a field of the generated function (under __func_impl__ ). New addhandler parameter (default: True) controls this behaviour. Fixes #16 Misc: New goodie to manipulate signatures: add_signature_parameters . Fixed dependencies for documentation auto-build. 0.5.0 - New helper function, and bugfix \u00b6 New helper function remove_signature_parameters . Fixed issue with @with_signature when argument is a Signature . Fixes #11 0.4.0 - New @with_signature decorator, and create_function accepts functions \u00b6 New decorator @with_signature to change the signature of a callable. Fixes #3 create_function now accepts that a function be passed as a signature template. Fixes #10 0.3.0 - Ability to generate functions from Signature \u00b6 Functions can now be created from a Signature object, in addition to string signatures. This unlocks many useful use cases, among easily creating function wrappers. Note: the inner function that provides this feature is get_signature_from_string . Fixes #8 Improved design by getting rid of the regular expression parser to check parameters definition. This assumes that the compiler will correctly raise exceptions when a string signature is not correct, and that inspect.signature or funcsigs.signature works correctly at detecting all the parameter kinds and annotations on the resulting function. It seems like a fair assumption... Fixes #9 . 0.2.0 - Various new features and improvements \u00b6 create_function : create_function does not require users to prepend \"def \" to the signature anymore. Fixed #5 Return annotations are now supported. Fixes #4 . Type hint as comments are supported but the generated function loses the annotations because inspect.signature loses the annotation too in that case. Fixes #7 Variable-length arguments such as *args and **kwargs are now properly handled. Fixes #2 Handler functions can now receive the dynamically created function as first argument, by using create_function(func_signature, func_handler, inject_as_first_arg=True) . Fixes #1 Renamed _call_ into _func_impl_ in the generated code. Misc: Added pytest-cases dependency for tests. 0.1.0 - First public version \u00b6 First version created, largely inspired by decorator","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#190-compile_fun-improvements-bugfix-and-better-exception","text":"@compile_fun : added capability to disable recursive compilation ( recurse arg) , and to exclude some names from compilation ( except_names arg). Fixed #49 and #50 Fixed issue ValueError: Cell is empty with @compile_fun . Fixed #48 Now raising an UndefinedSymbolError when a symbol is not known at compilation time. One step towards #47","title":"1.9.0 - @compile_fun improvements, bugfix and better exception"},{"location":"changelog/#180-new-compile_fun-goodie","text":"New goodie @compile_fun decorator to compile a function so that it can not be navigated to using the debugger. Fixes #46","title":"1.8.0 - new @compile_fun goodie"},{"location":"changelog/#170-minor-goodies-update","text":"add_signature_parameters now accepts that one specifies a custom index where to insert the new parameters.","title":"1.7.0 - minor goodies update"},{"location":"changelog/#1611-added-version-attribute","text":"Added __version__ attribute to comply with PEP396, following this guide . Fixes #45 .","title":"1.6.11 - Added version attribute"},{"location":"changelog/#1610-fixed-dependencies-2","text":"Fixed six dependency: also declared as a setup dependency.","title":"1.6.10 - Fixed dependencies 2"},{"location":"changelog/#169-fixed-dependencies","text":"Added missing six dependency explicitly.","title":"1.6.9 - Fixed dependencies"},{"location":"changelog/#168-improved-performance","text":"Improved performance of inner method get_signature_string (used by all entry points) after profiling.","title":"1.6.8 - Improved performance"},{"location":"changelog/#167-increased-tolerance-to-function-signatures-in-python-2","text":"In python 2 some libraries such as attrs can modify the annotations manually, making signature return a string representation that is not compliant with the language version. This raised a SyntaxError in previous versions. The new version silently removes all these annotations in python versions that do not support them. Fixes #39 .","title":"1.6.7 - Increased tolerance to function signatures in python 2"},{"location":"changelog/#166-bug-fix","text":"Fixed yet another nasty varpositional-related bug :). Fixes #38 .","title":"1.6.6 - Bug fix"},{"location":"changelog/#165-bug-fix","text":"Fixed NameError in case of unknown symbols in type hints. Fixes #37 .","title":"1.6.5 - Bug fix"},{"location":"changelog/#164-bug-fix-and-minor-improvement","text":"Fixed PEP8 error in source code. Fixes #35 . Now string signatures can contain a colon. Fixes #36","title":"1.6.4 - Bug fix and minor improvement"},{"location":"changelog/#163-bug-fix-with-type-hints-in-signature","text":"Fixed bug when the return type annotation of the function to create contains non-locally available type hints. Fixes #33 .","title":"1.6.3 - Bug fix with type hints in signature"},{"location":"changelog/#162-bug-fix-with-type-hints-in-signature","text":"Fixed bug when the signature of the function to create contains non-locally available type hints. Fixes #32 .","title":"1.6.2 - Bug fix with type hints in signature"},{"location":"changelog/#161-with_partial-and-partial-minor-bug-fix","text":"Fixed partial to support missing and empty docstring. Fixes #31 .","title":"1.6.1 - with_partial and partial minor bug fix"},{"location":"changelog/#160-added-with_partial-and-partial","text":"New method partial that behaves like functools.partial , and equivalent decorator @with_partial . Fixes #30 .","title":"1.6.0 - added with_partial and partial"},{"location":"changelog/#151-bug-fix","text":"add_signature_parameters now correctly inserts parameters in the right order when they are prepended (using first= ). Fixed #29 .","title":"1.5.1 - bug fix"},{"location":"changelog/#150-major-refactoring-and-bugfixes","text":"Function creation API: renamed all handler into impl for clarity. Fixes #27 . renamed addsource and addhandler arguments as add_source and add_impl respectively, for consistency signatures can not be provided as a callable anymore - that was far too confusing. If the reference signature is a callable, then use @wraps or create_wrapper , because that's probably what you want to do (= reuse not only the signature but also all metadata). Fixes #26 . the function name is now optional in signatures provided as string. now setting __qualname__ attribute default function name, qualname, doc and module name are the ones from func_impl in create_function and @with_signature , and are the ones from the wrapped function in create_wrapper and @wraps as intuitively expected. Fixes #28 . Wrappers: @wraps and create_wrapper now offer a new_sig argument. In that case the __wrapped__ attribute is not set. Fixes #25 . @wraps and create_wrapper now correctly preserve the __dict__ and other metadata from the wrapped item. Fixes #24","title":"1.5.0 - Major refactoring and bugfixes"},{"location":"changelog/#140-non-representable-default-values-are-now-handled-correctly","text":"When a non-representable default value was used in the signature to generate, the code failed with a SyntaxError . This case is now correctly handled, by storing the corresponding variable in the generated function's context. Fixes #23 .","title":"1.4.0 - Non-representable default values are now handled correctly"},{"location":"changelog/#130-aliases-for-signature-preserving-wrapper-scenarios","text":"Now providing a @wraps , equivalent of functools.wraps ; and a create_wrapper equivalent of functools.update_wrapper . Fixes #21 @with_signature now does not override the __name__ when signature is provided as a function. Fixes #22 add_signature_parameters now accepts that parameters are provided as single elements (not necessarily iterables) Updated documentation","title":"1.3.0 - Aliases for signature-preserving wrapper scenarios"},{"location":"changelog/#120-with_signature-supports-none","text":"None can be used as the desired signature of @with_signature . This indicated that the user does not want to create a new function but only wants to update the metadata. Fixes #20 .","title":"1.2.0 - @with_signature supports None"},{"location":"changelog/#112-fixes","text":"Fixed isgeneratorfunction for old python versions, see decorator#63 . Python<3.3-specific function body is now not loaded at all if not needed.","title":"1.1.2 - Fixes"},{"location":"changelog/#111-with_signature-fix","text":"inject_as_first_arg was missing from @with_signature , added it. Fixed #18 .","title":"1.1.1 - @with_signature fix"},{"location":"changelog/#110-support-for-generators-and-coroutines","text":"Now create_function and @with_signature create the same kind of function than the handler. So if it is a generator, a generator-based coroutine, or an async coroutine, the generated function will adapt. Fixes #6 .","title":"1.1.0 - Support for generators and coroutines"},{"location":"changelog/#102-fixed-with_signature","text":"Now a string signature can be provided to @with_signature without problem. Fixed #17 .","title":"1.0.2 - Fixed @with_signature"},{"location":"changelog/#101-minor-fixed-pypi-doc","text":"","title":"1.0.1 - minor: fixed PyPi doc"},{"location":"changelog/#100-new-parameters-new-goodie-and-bugfix","text":"@with_signature : now exposes all options of create_function . Fixed #12 . now correctly sets the module name by default. Fixes #13 now accepts None as the new func_signature to declare that the signature is identical to the decorated function. This can be handy to just change the docstring or module name of a function for example. Fixes #15 create_function and @with_signature : New module_name parameter to override the module name. Fixes #14 the handler is now available as a field of the generated function (under __func_impl__ ). New addhandler parameter (default: True) controls this behaviour. Fixes #16 Misc: New goodie to manipulate signatures: add_signature_parameters . Fixed dependencies for documentation auto-build.","title":"1.0.0 - New parameters, new goodie, and bugfix"},{"location":"changelog/#050-new-helper-function-and-bugfix","text":"New helper function remove_signature_parameters . Fixed issue with @with_signature when argument is a Signature . Fixes #11","title":"0.5.0 - New helper function, and bugfix"},{"location":"changelog/#040-new-with_signature-decorator-and-create_function-accepts-functions","text":"New decorator @with_signature to change the signature of a callable. Fixes #3 create_function now accepts that a function be passed as a signature template. Fixes #10","title":"0.4.0 - New @with_signature decorator, and create_function accepts functions"},{"location":"changelog/#030-ability-to-generate-functions-from-signature","text":"Functions can now be created from a Signature object, in addition to string signatures. This unlocks many useful use cases, among easily creating function wrappers. Note: the inner function that provides this feature is get_signature_from_string . Fixes #8 Improved design by getting rid of the regular expression parser to check parameters definition. This assumes that the compiler will correctly raise exceptions when a string signature is not correct, and that inspect.signature or funcsigs.signature works correctly at detecting all the parameter kinds and annotations on the resulting function. It seems like a fair assumption... Fixes #9 .","title":"0.3.0 - Ability to generate functions from Signature"},{"location":"changelog/#020-various-new-features-and-improvements","text":"create_function : create_function does not require users to prepend \"def \" to the signature anymore. Fixed #5 Return annotations are now supported. Fixes #4 . Type hint as comments are supported but the generated function loses the annotations because inspect.signature loses the annotation too in that case. Fixes #7 Variable-length arguments such as *args and **kwargs are now properly handled. Fixes #2 Handler functions can now receive the dynamically created function as first argument, by using create_function(func_signature, func_handler, inject_as_first_arg=True) . Fixes #1 Renamed _call_ into _func_impl_ in the generated code. Misc: Added pytest-cases dependency for tests.","title":"0.2.0 - Various new features and improvements"},{"location":"changelog/#010-first-public-version","text":"First version created, largely inspired by decorator","title":"0.1.0 - First public version"},{"location":"long_description/","text":"makefun \u00b6 Small library to dynamically create python functions. The documentation for users is available here: https://smarie.github.io/python-makefun/ A readme for developers is available here: https://github.com/smarie/python-makefun","title":"makefun"},{"location":"long_description/#makefun","text":"Small library to dynamically create python functions. The documentation for users is available here: https://smarie.github.io/python-makefun/ A readme for developers is available here: https://github.com/smarie/python-makefun","title":"makefun"}]}